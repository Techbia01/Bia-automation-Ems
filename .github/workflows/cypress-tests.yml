name: Pruebas E2E con Cypress

on:
  # Ejecutar en push a main/master
  push:
    branches:
      - main
      - master
      - develop
  
  # Ejecutar en pull requests
  pull_request:
    branches:
      - main
      - master
  
  # Ejecutar manualmente desde GitHub
  workflow_dispatch:
  
  # Programar ejecuci√≥n autom√°tica (horario en UTC)
  schedule:
    # Ejemplo: Todos los d√≠as a las 2:00 AM UTC (ajusta seg√∫n tu zona horaria)
    # Formato: minuto hora d√≠a mes d√≠a-semana
    # - cron: '0 2 * * *'  # Todos los d√≠as a las 2 AM UTC
    
    # Ejemplo: Lunes a Viernes a las 9:00 AM UTC
    # - cron: '0 9 * * 1-5'
    
    # Ejemplo: Todos los d√≠as a las 6:00 AM y 6:00 PM UTC
    - cron: '0 6,18 * * *'
    
    # Ejemplo: Solo los lunes a las 8:00 AM UTC
    # - cron: '0 8 * * 1'

jobs:
  cypress-run:
    name: Ejecutar pruebas Cypress
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout c√≥digo
        uses: actions/checkout@v4
      
      - name: Configurar Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Instalar dependencias
        run: |
          if [ -f package-lock.json ]; then
            npm ci
          else
            npm install
          fi
      
      - name: Ejecutar pruebas Cypress
        id: cypress-run
        uses: cypress-io/github-action@v6
        continue-on-error: true
        with:
          # Ejecutar en modo headless
          runTests: true
          # Browser a usar
          browser: chrome
          # Esperar a que el servidor est√© listo (si aplica)
          wait-on: 'https://web.dev.bia.app'
          wait-on-timeout: 120
          # Configuraci√≥n adicional
          record: false
          parallel: false
          # Ejecutar todos los specs
          spec: 'cypress/e2e/**/*.cy.js'
        env:
          # Variables de entorno si las necesitas
          CYPRESS_BASE_URL: ${{ secrets.CYPRESS_BASE_URL || 'https://web.dev.bia.app' }}
          # Configuraci√≥n para evitar timeouts
          CYPRESS_defaultCommandTimeout: 30000
          CYPRESS_requestTimeout: 30000
          CYPRESS_responseTimeout: 30000
          CYPRESS_pageLoadTimeout: 60000
      
      - name: Parsear resultados de Cypress
        id: parse-results
        if: always()
        run: |
          mkdir -p cypress/results
          
          # Intentar usar el script de parseo si existe
          if [ -f "scripts/parse-cypress-results.js" ]; then
            node scripts/parse-cypress-results.js || true
          fi
          
          # Leer estad√≠sticas si el script las gener√≥
          if [ -f "cypress/results/stats.json" ]; then
            STATS=$(cat cypress/results/stats.json)
            TESTS=$(echo "$STATS" | grep -oP '"tests":\s*\K\d+' || echo "0")
            PASSES=$(echo "$STATS" | grep -oP '"passes":\s*\K\d+' || echo "0")
            FAILURES=$(echo "$STATS" | grep -oP '"failures":\s*\K\d+' || echo "0")
            
            echo "tests=$TESTS" >> $GITHUB_OUTPUT
            echo "passes=$PASSES" >> $GITHUB_OUTPUT
            echo "failures=$FAILURES" >> $GITHUB_OUTPUT
            
            # Leer pruebas fallidas
            if [ -f "cypress/results/stats.json" ]; then
              FAILED_TESTS_JSON=$(node -e "const fs=require('fs'); const data=JSON.parse(fs.readFileSync('cypress/results/stats.json')); console.log(JSON.stringify(data.failedTests || []))" 2>/dev/null || echo "[]")
              PASSED_TESTS_JSON=$(node -e "const fs=require('fs'); const data=JSON.parse(fs.readFileSync('cypress/results/stats.json')); console.log(JSON.stringify(data.passedTests || []))" 2>/dev/null || echo "[]")
              
              echo "failed_tests<<EOF" >> $GITHUB_OUTPUT
              echo "$FAILED_TESTS_JSON" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
              
              echo "passed_tests<<EOF" >> $GITHUB_OUTPUT
              echo "$PASSED_TESTS_JSON" >> $GITHUB_OUTPUT
              echo "EOF" >> $GITHUB_OUTPUT
            fi
            
            # Determinar estado general
            if [ "$FAILURES" -eq 0 ] && [ "$TESTS" -gt 0 ]; then
              echo "status=success" >> $GITHUB_OUTPUT
              echo "message=‚úÖ Todas las $TESTS pruebas pasaron exitosamente" >> $GITHUB_OUTPUT
              echo "color=good" >> $GITHUB_OUTPUT
            elif [ "$FAILURES" -gt 0 ]; then
              echo "status=failure" >> $GITHUB_OUTPUT
              echo "message=‚ùå $FAILURES de $TESTS pruebas fallaron ($PASSES pasaron)" >> $GITHUB_OUTPUT
              echo "color=danger" >> $GITHUB_OUTPUT
            else
              # Fallback: usar el resultado del step de Cypress
              if [ "${{ steps.cypress-run.outcome }}" == "success" ]; then
                echo "status=success" >> $GITHUB_OUTPUT
                echo "message=‚úÖ Todas las pruebas pasaron exitosamente" >> $GITHUB_OUTPUT
                echo "color=good" >> $GITHUB_OUTPUT
              else
                echo "status=failure" >> $GITHUB_OUTPUT
                echo "message=‚ùå Algunas pruebas fallaron" >> $GITHUB_OUTPUT
                echo "color=danger" >> $GITHUB_OUTPUT
              fi
              echo "tests=0" >> $GITHUB_OUTPUT
              echo "passes=0" >> $GITHUB_OUTPUT
              echo "failures=0" >> $GITHUB_OUTPUT
            fi
          else
            # Fallback: usar el resultado del step de Cypress
            if [ "${{ steps.cypress-run.outcome }}" == "success" ]; then
              echo "status=success" >> $GITHUB_OUTPUT
              echo "message=‚úÖ Todas las pruebas pasaron exitosamente" >> $GITHUB_OUTPUT
              echo "color=good" >> $GITHUB_OUTPUT
            else
              echo "status=failure" >> $GITHUB_OUTPUT
              echo "message=‚ùå Algunas pruebas fallaron" >> $GITHUB_OUTPUT
              echo "color=danger" >> $GITHUB_OUTPUT
            fi
            echo "tests=0" >> $GITHUB_OUTPUT
            echo "passes=0" >> $GITHUB_OUTPUT
            echo "failures=0" >> $GITHUB_OUTPUT
            echo "failed_tests=[]" >> $GITHUB_OUTPUT
            echo "passed_tests=[]" >> $GITHUB_OUTPUT
          fi
      
      - name: Obtener resultado de pruebas
        id: test-result
        if: always()
        run: |
          # Este step ahora solo usa los outputs del step anterior
          echo "Usando resultados parseados del step anterior"
      
      - name: Subir videos de pruebas
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cypress-videos
          path: cypress/videos
          retention-days: 7
      
      - name: Subir screenshots de fallos
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-screenshots
          path: cypress/screenshots
          retention-days: 7
      
      - name: Publicar resultados
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cypress-results
          path: |
            cypress/videos
            cypress/screenshots
          retention-days: 7
      
      - name: Mostrar resumen de pruebas fallidas
        if: failure()
        run: |
          echo "## ‚ùå Pruebas Fallidas" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f "cypress/results/stats.json" ]; then
            node << 'NODE_SCRIPT'
          const fs = require('fs');
          try {
            const data = JSON.parse(fs.readFileSync('cypress/results/stats.json', 'utf8'));
            const failedTests = data.failedTests || [];
            
            if (failedTests.length > 0) {
              console.log('### Detalles de Pruebas Fallidas:\n');
              failedTests.forEach((test, index) => {
                const testName = typeof test === 'string' ? test : (test.name || 'Test sin nombre');
                const error = typeof test === 'object' && test.error ? test.error : '';
                
                console.log(`${index + 1}. **${testName}**`);
                if (error) {
                  const shortError = error.length > 200 ? error.substring(0, 200) + '...' : error;
                  console.log(`   \`\`\`\n${shortError}\n\`\`\``);
                }
                console.log('');
              });
            } else {
              console.log('No se encontraron detalles de pruebas fallidas en el archivo JSON.');
            }
          } catch (error) {
            console.log('Error leyendo estad√≠sticas:', error.message);
          }
          NODE_SCRIPT
          else
            echo "No se encontr√≥ archivo de estad√≠sticas. Revisa los logs de Cypress arriba." >> $GITHUB_STEP_SUMMARY
          fi
      
      - name: Generar mensaje de Slack
        id: generate-slack-message
        if: always()
        env:
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          GITHUB_SERVER_URL: ${{ github.server_url }}
          STATUS_MESSAGE: ${{ steps.parse-results.outputs.message }}
          COLOR: ${{ steps.parse-results.outputs.color }}
          TESTS: ${{ steps.parse-results.outputs.tests }}
          PASSES: ${{ steps.parse-results.outputs.passes }}
          FAILURES: ${{ steps.parse-results.outputs.failures }}
        run: |
          echo "=== Generando mensaje de Slack ==="
          echo "STATUS_MESSAGE: $STATUS_MESSAGE"
          echo "COLOR: $COLOR"
          echo "TESTS: $TESTS"
          echo "PASSES: $PASSES"
          echo "FAILURES: $FAILURES"
          
          # Verificar si existe el archivo de estad√≠sticas
          if [ -f "cypress/results/stats.json" ]; then
            echo "Archivo stats.json encontrado"
            cat cypress/results/stats.json | head -20
          else
            echo "‚ö†Ô∏è Archivo stats.json NO encontrado"
          fi
          
          # Ejecutar script para generar payload de Slack
          if [ -f "scripts/generate-slack-message.js" ]; then
            echo "Ejecutando script generate-slack-message.js..."
            node scripts/generate-slack-message.js || echo "‚ö†Ô∏è Error ejecutando script, usando fallback"
          else
            echo "‚ö†Ô∏è Script generate-slack-message.js NO encontrado"
          fi
          
          # Si no se gener√≥ el payload, crear uno con los valores reales
          if [ ! -f "slack-payload.json" ]; then
            echo "Generando payload de fallback..."
            node << 'NODE_SCRIPT'
          const fs = require('fs');
          
          const statusMessage = process.env.STATUS_MESSAGE || 'Pruebas completadas';
          const color = process.env.COLOR || 'good';
          const tests = parseInt(process.env.TESTS || '0');
          const passes = parseInt(process.env.PASSES || '0');
          const failures = parseInt(process.env.FAILURES || '0');
          
          // Leer pruebas fallidas si existen
          let failedTests = [];
          try {
            if (fs.existsSync('cypress/results/stats.json')) {
              const statsData = JSON.parse(fs.readFileSync('cypress/results/stats.json', 'utf8'));
              failedTests = statsData.failedTests || [];
            }
          } catch (e) {
            console.error('Error leyendo stats.json:', e.message);
          }
          
          const payload = {
            text: statusMessage,
            blocks: [
              {
                type: 'header',
                text: {
                  type: 'plain_text',
                  text: 'üß™ Reporte de Pruebas Cypress'
                }
              },
              {
                type: 'section',
                fields: [
                  {
                    type: 'mrkdwn',
                    text: `*Estado:*\n${statusMessage}`
                  },
                  {
                    type: 'mrkdwn',
                    text: `*Repositorio:*\n${process.env.GITHUB_REPOSITORY}`
                  },
                  {
                    type: 'mrkdwn',
                    text: `*Rama:*\n${process.env.GITHUB_REF_NAME}`
                  },
                  {
                    type: 'mrkdwn',
                    text: `*Commit:*\n<${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/commit/${process.env.GITHUB_SHA}|${process.env.GITHUB_SHA.substring(0, 7)}>`
                  },
                  {
                    type: 'mrkdwn',
                    text: `*Ejecutado por:*\n${process.env.GITHUB_ACTOR}`
                  },
                  {
                    type: 'mrkdwn',
                    text: `*Workflow:*\n<${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}|Ver detalles>`
                  }
                ]
              }
            ],
            attachments: [
              {
                color: color,
                footer: 'GitHub Actions'
              }
            ]
          };
          
          // Agregar estad√≠sticas
          if (tests > 0) {
            payload.blocks.push({
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `*üìä Estad√≠sticas:*\n‚Ä¢ Total: ${tests}\n‚Ä¢ ‚úÖ Pasaron: ${passes}\n‚Ä¢ ‚ùå Fallaron: ${failures}`
              }
            });
          }
          
          // Agregar pruebas fallidas si las hay - MOSTRAR TODAS
          if (failedTests.length > 0) {
            // T√≠tulo destacado
            payload.blocks.push({
              type: 'section',
              text: {
                type: 'mrkdwn',
                text: `*‚ùå CASOS QUE FALLARON (${failedTests.length}):*`
              }
            });
            
            // Dividir en bloques si hay muchas pruebas
            const testsPerBlock = 15;
            const totalBlocks = Math.ceil(failedTests.length / testsPerBlock);
            
            for (let blockIndex = 0; blockIndex < totalBlocks; blockIndex++) {
              const startIndex = blockIndex * testsPerBlock;
              const endIndex = Math.min(startIndex + testsPerBlock, failedTests.length);
              
              let failedTestsText = '';
              
              for (let i = startIndex; i < endIndex; i++) {
                const test = failedTests[i];
                const testName = typeof test === 'string' ? test : (test.name || 'Test sin nombre');
                
                // Limpiar nombre del test
                const cleanTestName = testName
                  .replace(/cypress\/e2e\//g, '')
                  .replace(/\.cy\.js/g, '')
                  .replace(/\//g, ' > ')
                  .trim();
                
                failedTestsText += `\n*${i + 1}.* \`${cleanTestName}\``;
                
                if (typeof test === 'object' && test.error) {
                  const error = test.error.length > 200 ? test.error.substring(0, 200) + '...' : test.error;
                  const cleanError = error.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
                  failedTestsText += `\n   _${cleanError}_`;
                }
              }
              
              payload.blocks.push({
                type: 'section',
                text: {
                  type: 'mrkdwn',
                  text: failedTestsText
                }
              });
            }
            
            // Separador
            payload.blocks.push({
              type: 'divider'
            });
          }
          
          payload.blocks.push({
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: `<${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}|üìä Ver resultados completos en GitHub>`
            }
          });
          
          fs.writeFileSync('slack-payload.json', JSON.stringify(payload, null, 2));
          console.log('Payload de Slack generado exitosamente');
          NODE_SCRIPT
          fi
      
      - name: Verificar payload de Slack
        if: always()
        continue-on-error: true
        run: |
          echo "=== Verificando payload de Slack ==="
          if [ -f "slack-payload.json" ]; then
            echo "‚úÖ Archivo slack-payload.json encontrado"
            echo "Tama√±o del archivo:"
            ls -lh slack-payload.json
            echo ""
            echo "Contenido del payload (primeras 50 l√≠neas):"
            head -50 slack-payload.json
          else
            echo "‚ùå ERROR: Archivo slack-payload.json NO encontrado"
            echo "Listando archivos en el directorio:"
            ls -la
            echo "‚ö†Ô∏è Intentando crear payload m√≠nimo..."
            # Crear un payload m√≠nimo de emergencia
            cat > slack-payload.json << 'EOF'
          {
            "text": "Pruebas de Cypress completadas",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*üß™ Reporte de Pruebas Cypress*\n\nLas pruebas se completaron. Revisa los detalles en GitHub Actions."
                }
              }
            ]
          }
          EOF
          fi
          
          # Verificar que el webhook est√© configurado
          if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "‚ùå ERROR CR√çTICO: SLACK_WEBHOOK_URL no est√° configurado"
            echo "Ve a: Settings ‚Üí Secrets ‚Üí Actions ‚Üí New repository secret"
            echo "Nombre: SLACK_WEBHOOK_URL"
            echo "Valor: Tu webhook URL de Slack"
          else
            echo "‚úÖ SLACK_WEBHOOK_URL est√° configurado"
          fi
      
      - name: Enviar notificaci√≥n a Slack
        if: always()
        continue-on-error: true
        uses: slackapi/slack-github-action@v1
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          payload-file-path: slack-payload.json
        id: slack-notification
      
      - name: Verificar resultado de env√≠o a Slack
        if: always()
        continue-on-error: true
        run: |
          echo "=== Verificaci√≥n de env√≠o a Slack ==="
          echo ""
          
          # Verificar webhook
          if [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "‚ùå SLACK_WEBHOOK_URL NO est√° configurado"
            echo "   ‚Üí Ve a: Settings ‚Üí Secrets ‚Üí Actions"
            echo "   ‚Üí Crea un secret llamado: SLACK_WEBHOOK_URL"
            echo "   ‚Üí Pega tu webhook URL de Slack (formato: https://hooks.slack.com/services/...)"
            echo ""
            echo "‚ö†Ô∏è Las notificaciones NO se enviar√°n hasta que configures el secret"
          else
            echo "‚úÖ SLACK_WEBHOOK_URL est√° configurado"
          fi
          
          # Verificar payload
          if [ -f "slack-payload.json" ]; then
            echo "‚úÖ slack-payload.json generado correctamente"
            PAYLOAD_SIZE=$(wc -c < slack-payload.json)
            echo "   Tama√±o: ${PAYLOAD_SIZE} bytes"
          else
            echo "‚ùå slack-payload.json NO se gener√≥"
            echo "   ‚Üí Revisa los logs del paso 'Generar mensaje de Slack'"
          fi
          
          # Verificar si se envi√≥
          if [ "${{ steps.slack-notification.outcome }}" == "success" ]; then
            echo "‚úÖ Notificaci√≥n enviada exitosamente a Slack"
          elif [ "${{ steps.slack-notification.outcome }}" == "failure" ]; then
            echo "‚ùå Error al enviar notificaci√≥n a Slack"
            echo "   ‚Üí Revisa los logs del paso 'Enviar notificaci√≥n a Slack'"
            echo "   ‚Üí Verifica que el webhook URL sea v√°lido"
          elif [ -z "${{ secrets.SLACK_WEBHOOK_URL }}" ]; then
            echo "‚ö†Ô∏è Paso de Slack no se ejecut√≥ (webhook no configurado)"
          else
            echo "‚ö†Ô∏è Estado desconocido del env√≠o"
          fi
          
          echo ""
          echo "üîç Para m√°s ayuda:"
          echo "1. Revisa los logs del paso 'Enviar notificaci√≥n a Slack'"
          echo "2. Verifica que el webhook URL sea v√°lido en Slack"
          echo "3. Prueba el webhook manualmente con:"
          echo "   curl -X POST -H 'Content-type: application/json' --data '{\"text\":\"Test\"}' TU_WEBHOOK_URL"

